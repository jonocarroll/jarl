#[derive(Debug, PartialEq)]
pub enum LintDirective {
    /// Skip all lints for the next node
    Skip,
    /// Skip specific lints for the next node, e.g. "# nolint: any_is_na, coalesce"
    SkipRules(Vec<String>),
    /// Skip an entire file
    SkipFile,
    /// Start a block where all lints are skipped
    SkipStart,
    /// Start a block where specific lints are skipped
    SkipStartRules(Vec<String>),
    /// End a skip block
    SkipEnd,
}

/// Parse a comment directive
///
/// These can take the form:
///
/// ```text
/// # nolint
/// # nolint: rule1, rule2
/// # nolint start
/// # nolint start: rule1, rule2
/// # nolint end
/// ```
///
/// Note that directives are applied to the node they are attached to,
/// except for start/end directives which define regions.
///
/// `text` should be single line but we don't check for this. A potential usage
/// of this function is to iterate over a document line by line to scan for a
/// directive.
///
/// Returns:
/// - `Some(directive)` - A valid directive was found
/// - `None` - Invalid directive (e.g. `# nolint:`) or just a regular comment
pub fn parse_comment_directive(text: &str) -> Option<LintDirective> {
    // Only allow single # followed by space
    let text = text.trim_start();
    if !text.starts_with("# ") {
        return None;
    }

    let text = &text[2..]; // Skip "# "

    // Handle "nolint" specially to allow various forms
    if let Some(stripped) = text.strip_prefix("nolint") {
        let rest = stripped.trim_start();
        if rest.is_empty() {
            // "# nolint" with nothing after -> skip all
            return Some(LintDirective::Skip);
        } else if let Some(after_start) = rest.strip_prefix("start") {
            // "# nolint start" or "# nolint start: rules"
            let after_start = after_start.trim_start();
            if after_start.is_empty() {
                // "# nolint start" -> skip all in block
                return Some(LintDirective::SkipStart);
            } else if let Some(after_colon) = after_start.strip_prefix(':') {
                // "# nolint start: rules"
                let after_colon = after_colon.trim();
                return parse_lint_directive_for_start(after_colon);
            } else {
                // "# nolint start" followed by something that's not a colon -> invalid
                return None;
            }
        } else if rest == "end" {
            // "# nolint end"
            return Some(LintDirective::SkipEnd);
        } else if let Some(after_colon) = rest.strip_prefix(':') {
            // "# nolint: rules"
            let after_colon = after_colon.trim();
            return parse_lint_directive(after_colon);
        } else {
            // "# nolint" followed by something that's not recognized -> invalid
            return None;
        }
    }

    None
}

// https://github.com/posit-dev/air/issues/219
// Should be called only on the first line in a block of comments.
pub fn parse_special_skip_file(text: &str) -> Option<LintDirective> {
    // Only allow single # followed by space
    let text = text.trim_start();
    if !text.starts_with("# ") {
        return None;
    }

    let text = &text[2..]; // Skip "# "

    // Convention used in the R community (Roxygen, Rcpp, etc)
    if text.starts_with("Generated by") {
        return Some(LintDirective::SkipFile);
    }

    None
}

#[inline]
fn parse_lint_directive(text: &str) -> Option<LintDirective> {
    // Parse comma-separated rule names, e.g. "any_is_na, coalesce"
    let rules: Vec<String> = text
        .split(',')
        .map(|s| s.trim().trim_end_matches("_linter").to_string())
        .filter(|s| !s.is_empty())
        .collect();

    if rules.is_empty() {
        None
    } else {
        Some(LintDirective::SkipRules(rules))
    }
}

#[inline]
fn parse_lint_directive_for_start(text: &str) -> Option<LintDirective> {
    // Parse comma-separated rule names for start directive
    let rules: Vec<String> = text
        .split(',')
        .map(|s| s.trim().trim_end_matches("_linter").to_string())
        .filter(|s| !s.is_empty())
        .collect();

    if rules.is_empty() {
        None
    } else {
        Some(LintDirective::SkipStartRules(rules))
    }
}

#[cfg(test)]
mod test {
    use crate::LintDirective;
    use crate::parse_comment_directive;

    #[test]
    fn test_lint_directive() {
        let lint_skip = Some(LintDirective::Skip);

        // "# nolint" without colon should skip all (must have space after #)
        assert_eq!(parse_comment_directive("# nolint"), lint_skip);

        // Without space after # should not work
        assert_eq!(parse_comment_directive("#nolint"), None);
        assert_eq!(parse_comment_directive("##nolint"), None);
        assert_eq!(parse_comment_directive("## nolint"), None);

        assert_eq!(parse_comment_directive("# nolint:"), None);
        assert_eq!(parse_comment_directive("#nolint:"), None);
        assert_eq!(parse_comment_directive("# nolint: "), None);

        // Skip specific rules
        let result = parse_comment_directive("# nolint: any_is_na");
        assert!(matches!(
            result,
            Some(LintDirective::SkipRules(ref rules)) if rules == &vec!["any_is_na"]
        ));

        let result = parse_comment_directive("# nolint: any_is_na, coalesce");
        assert!(matches!(
            result,
            Some(LintDirective::SkipRules(ref rules))
            if rules == &vec!["any_is_na", "coalesce"]
        ));

        // lintr compatibility: also accept rule names that end with "_linter"
        let result = parse_comment_directive("# nolint: any_is_na_linter");
        assert!(matches!(
            result,
            Some(LintDirective::SkipRules(ref rules)) if rules == &vec!["any_is_na"]
        ));

        let result = parse_comment_directive("# nolint: any_is_na_linter, coalesce_linter");
        assert!(matches!(
            result,
            Some(LintDirective::SkipRules(ref rules))
            if rules == &vec!["any_is_na", "coalesce"]
        ));

        // With extra spaces
        let result = parse_comment_directive("# nolint:  any_is_na  ,  coalesce_linter  ");
        assert!(matches!(
            result,
            Some(LintDirective::SkipRules(ref rules))
            if rules == &vec!["any_is_na", "coalesce"]
        ));

        // Can't have unrelated leading text
        assert_eq!(parse_comment_directive("# please nolint:"), None);
        assert_eq!(parse_comment_directive("# please nolint"), None);

        // Can't have text after nolint without a colon
        assert_eq!(parse_comment_directive("# nolint any_is_na"), None);
    }

    #[test]
    fn test_lint_directive_start_end() {
        // "# nolint start" should start skipping all
        assert_eq!(
            parse_comment_directive("# nolint start"),
            Some(LintDirective::SkipStart)
        );

        // "# nolint end" should end skipping
        assert_eq!(
            parse_comment_directive("# nolint end"),
            Some(LintDirective::SkipEnd)
        );

        // "# nolint start: rules" should start skipping specific rules
        let result = parse_comment_directive("# nolint start: any_is_na");
        assert!(matches!(
            result,
            Some(LintDirective::SkipStartRules(ref rules)) if rules == &vec!["any_is_na"]
        ));

        let result = parse_comment_directive("# nolint start: any_is_na, coalesce");
        assert!(matches!(
            result,
            Some(LintDirective::SkipStartRules(ref rules))
            if rules == &vec!["any_is_na", "coalesce"]
        ));

        // With extra spaces
        let result = parse_comment_directive("# nolint start:  any_is_na  ,  coalesce_linter  ");
        assert!(matches!(
            result,
            Some(LintDirective::SkipStartRules(ref rules))
            if rules == &vec!["any_is_na", "coalesce"]
        ));

        // Invalid forms
        assert_eq!(parse_comment_directive("# nolint start:"), None);
        assert_eq!(parse_comment_directive("# nolint start: "), None);
        assert_eq!(parse_comment_directive("# nolint start any_is_na"), None);
        assert_eq!(parse_comment_directive("# nolint ending"), None);
    }
}
